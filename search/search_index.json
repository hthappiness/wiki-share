{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"lua/","text":"Skia Lua Bindings Warning: The following has only been tested on Mac and Linux, but it will likely work for any Unix. Prerequisites This assumes you already have Skia building normally. If not, refer to How to build Skia . Build To build Lua support into Skia tools, set the GN argument skia_use_lua to true . Optionally, set skia_use_system_lua . Then re-run GN. Try It Out The tools lua_app and lua_pictures should now be available when you compile, and Viewer should now have a Lua sample. To-Do Skia had a feature that let it be imported as an .so by Lua. This feature is not yet supported by GN, but would have looked something like this: $ lua Lua 5.2.0 Copyright (C) 1994-2011 Lua.org, PUC-Rio > require 'skia' > paint = Sk.newPaint() > paint:setColor{a=1, r=1, g=0, b=0} > doc = Sk.newDocumentPDF('test.pdf') > canvas = doc:beginPage(72*8.5, 72*11) > canvas:drawText('Hello Lua', 300, 300, paint) > doc:close()","title":"Lua"},{"location":"lua/#skia-lua-bindings","text":"Warning: The following has only been tested on Mac and Linux, but it will likely work for any Unix.","title":"Skia Lua Bindings"},{"location":"lua/#prerequisites","text":"This assumes you already have Skia building normally. If not, refer to How to build Skia .","title":"Prerequisites"},{"location":"lua/#build","text":"To build Lua support into Skia tools, set the GN argument skia_use_lua to true . Optionally, set skia_use_system_lua . Then re-run GN.","title":"Build"},{"location":"lua/#try-it-out","text":"The tools lua_app and lua_pictures should now be available when you compile, and Viewer should now have a Lua sample.","title":"Try It Out"},{"location":"lua/#to-do","text":"Skia had a feature that let it be imported as an .so by Lua. This feature is not yet supported by GN, but would have looked something like this: $ lua Lua 5.2.0 Copyright (C) 1994-2011 Lua.org, PUC-Rio > require 'skia' > paint = Sk.newPaint() > paint:setColor{a=1, r=1, g=0, b=0} > doc = Sk.newDocumentPDF('test.pdf') > canvas = doc:beginPage(72*8.5, 72*11) > canvas:drawText('Hello Lua', 300, 300, paint) > doc:close()","title":"To-Do"},{"location":"vulkan/","text":"Vulkan Skia has a Vulkan implementation of its GPU backend. The Vulkan backend can be built alongside the OpenGL backend. The client can select between the OpenGL and Vulkan implementation at runtime. The Vulkan backend has reached feature parity with the OpenGL backend. At this time we find that many Vulkan drivers have bugs that Skia triggers for which we have no workaround. We are reporting bugs to vendors as we find them. Windows and Linux To build the Vulkan backend, set skia_vulkan_sdk to the path to your Vulkan SDK in args.gn . This defaults to the environment variable VULKAN_SDK . Android The Vulkan backend can run on any device with Vulkan drivers, including all Android N+ devices. To build the Vulkan backend, set ndk_api = 24 in args.gn to target Android N. Using the Vulkan Backend To create a GrContext that is backed by Vulkan the client creates a Vulkan device and queue, initializes a GrVkBackendContext to describe the context, and then calls GrContext::MakeVulkan: sk_sp<GrVkBackendContext> vkContext = new GrVkBackendContext; vkBackendContext.fInstance = vkInstance; vkBackendContext.fPhysicalDevice = vkPhysDevice; ... vkBackendContext.fInterface.reset(GrVkCreateInterface(instance, vkPhysDevice, extensionFlags); ... sk_sp<GrContext> context = GrContext::MakeVulkan(vkBackendContext); When using the Vulkan backend, GrVkImageInfo is used to construct GrBackendTexture and GrBackendRenderTarget objects that in turn are used to create SkSurface and SkImage objects that refer to VkImages created by the Skia client. The GrBackendObject returned by SkImage::getTextureHandle(), SkSurface::getTextureHandle(), and SkSurface::getRenderTargetHandle() should be interpreted as a GrVkImageInfo*. This allows a client to get the backing VkImage of a SkImage or SkSurface. GrVkImageInfo specifies a VkImage and associated state (tiling, layout, format, etc). After getting a GrVkImageInfo* via getTextureHandle() or getRenderTargetHandle(), the client should check the fImageLayout field to know what layout Skia left the VkImage in before using the VkImage. If the client changes the layout of the VkImage, GrVkImageInfo::updateImageLayout(VkImageLayout layout) should be called before resuming Skia rendering. The client is responsible for any synchronization or barriers needed before Skia performs I/O on a VkImage imported into Skia via GrVkImageInfo. Skia will assume it can start issuing commands referencing the VkImage without the need for additional synchronization.","title":"Vulkan"},{"location":"vulkan/#vulkan","text":"Skia has a Vulkan implementation of its GPU backend. The Vulkan backend can be built alongside the OpenGL backend. The client can select between the OpenGL and Vulkan implementation at runtime. The Vulkan backend has reached feature parity with the OpenGL backend. At this time we find that many Vulkan drivers have bugs that Skia triggers for which we have no workaround. We are reporting bugs to vendors as we find them.","title":"Vulkan"},{"location":"vulkan/#windows-and-linux","text":"To build the Vulkan backend, set skia_vulkan_sdk to the path to your Vulkan SDK in args.gn . This defaults to the environment variable VULKAN_SDK .","title":"Windows and Linux"},{"location":"vulkan/#android","text":"The Vulkan backend can run on any device with Vulkan drivers, including all Android N+ devices. To build the Vulkan backend, set ndk_api = 24 in args.gn to target Android N.","title":"Android"},{"location":"vulkan/#using-the-vulkan-backend","text":"To create a GrContext that is backed by Vulkan the client creates a Vulkan device and queue, initializes a GrVkBackendContext to describe the context, and then calls GrContext::MakeVulkan: sk_sp<GrVkBackendContext> vkContext = new GrVkBackendContext; vkBackendContext.fInstance = vkInstance; vkBackendContext.fPhysicalDevice = vkPhysDevice; ... vkBackendContext.fInterface.reset(GrVkCreateInterface(instance, vkPhysDevice, extensionFlags); ... sk_sp<GrContext> context = GrContext::MakeVulkan(vkBackendContext); When using the Vulkan backend, GrVkImageInfo is used to construct GrBackendTexture and GrBackendRenderTarget objects that in turn are used to create SkSurface and SkImage objects that refer to VkImages created by the Skia client. The GrBackendObject returned by SkImage::getTextureHandle(), SkSurface::getTextureHandle(), and SkSurface::getRenderTargetHandle() should be interpreted as a GrVkImageInfo*. This allows a client to get the backing VkImage of a SkImage or SkSurface. GrVkImageInfo specifies a VkImage and associated state (tiling, layout, format, etc). After getting a GrVkImageInfo* via getTextureHandle() or getRenderTargetHandle(), the client should check the fImageLayout field to know what layout Skia left the VkImage in before using the VkImage. If the client changes the layout of the VkImage, GrVkImageInfo::updateImageLayout(VkImageLayout layout) should be called before resuming Skia rendering. The client is responsible for any synchronization or barriers needed before Skia performs I/O on a VkImage imported into Skia via GrVkImageInfo. Skia will assume it can start issuing commands referencing the VkImage without the need for additional synchronization.","title":"Using the Vulkan Backend"}]}